import { OptimisticLocalStore } from "convex-dev/browser"
import { ConvexProvider, ConvexReactClient } from 'convex-dev/react'
import type { NextPage } from 'next'
import Head from 'next/head'
import Image from 'next/image'
import { ConvexAPI, useMutation, useQuery } from '../convex/_generated'
import styles from '../styles/Home.module.css'
import config from "../convex.json";
import { FormEvent, useCallback, useState } from 'react'
import { Id } from "convex-dev/values"

const convex = new ConvexReactClient(config.origin)

function QnA() {
  const questions = useQuery("questions:loadQuestions");
  const noNewQuestions = useQuery("stopQuestions:isStopped") ?? true;
  const upvote = useMutation("questions:upvote")
  const downvote = useMutation("questions:downvote");
  const rollTheDice = useMutation("questions:rollTheDice");

  const optimisticUpvote = upvote.withOptimisticUpdate((queryStore, id) => {
    applyIncrement(queryStore, id, 1);
  });
  const optimisticDownvote = downvote.withOptimisticUpdate((queryStore, id) => {
    applyIncrement(queryStore, id, -1);
  });

  return (
    <main className={styles.main}>
      <h1 className={styles.title}>
        ü§î Livestream Q&amp;A
      </h1>
      {!noNewQuestions && <AddQuestions />}
      <table className={styles.questions}>
        <tbody>
          {questions?.map(q => {
            return (
              <tr key={q.id.toString()}>
                <td>
                  {q.text}
                </td>
                <td>
                  {formatCount(q.votes)}
                </td>
                <td>
                  <button onClick={() => optimisticUpvote(q.id)}>üëç</button>
                </td>
                <td>
                  <button onClick={() => optimisticDownvote(q.id)}>üëé</button>
                </td>
                <td>
                  <button onClick={() => rollTheDice(q.id)}>üé≤</button>
                </td>
              </tr>
            )
          })}
        </tbody>
      </table>
    </main>
  )
}

function AddQuestions() {
  const addQuestion = useMutation("newQuestion");
  const stopQuestions = useMutation("stopQuestions:stopQuestions")
  const [text, setText] = useState("");
  const updateText = useCallback((e: FormEvent<HTMLInputElement>) => {
    setText(e.currentTarget.value);
  }, [setText]);
  const submit = useCallback((e: FormEvent) => {
    e.preventDefault();
    if (text) {
      setText("");
      addQuestion(text);
    }
  }, [text, addQuestion])
  return (
    <div className={styles.addQuestion}>
      <form onSubmit={submit}>
        <input type="text" value={text} onChange={updateText}/>
        <button onClick={submit}>Add another question</button>
      </form>
      <button onClick={() => stopQuestions()}>No more questions.</button>
    </div>
  )
}

const Home: NextPage = () => {
  return (
    <div className={styles.container}>
      <Head>
        <title>Livestream Q&amp;A</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <ConvexProvider client={convex}>
        <QnA/>
      </ConvexProvider>

      <footer className={styles.footer}>
        <a
          href="https://vercel.com?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          Powered by{' '}
          <span className={styles.logo}>
            <Image src="/vercel.svg" alt="Vercel Logo" width={72} height={16} />
          </span>
        </a>
      </footer>
    </div>
  )
}

function formatCount(n: number) {
  const className = n < 0 ? styles.negative : n == 0 ? styles.zero : styles.positive;
  return <span className={className}>{n}</span>;
}

function applyIncrement(store: OptimisticLocalStore<ConvexAPI>, id: Id, increment: number) {
  const questions = store.getQuery("questions:loadQuestions", []);
  if (!questions) {
    return;
  }
  const newQuestions = questions.map(question => {
    if (question.id.equals(id)) {
      return {...question, votes: question.votes + increment };
    }
    return question;
  });
  newQuestions.sort((a, b) => b.votes - a.votes);
  store.setQuery("questions:loadQuestions", [], newQuestions);
}

export default Home
